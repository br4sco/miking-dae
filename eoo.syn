language EOOParse

start EOOProg

type EOOProg
type EOOTop
type EOOParam
type EOOBinding
type EOOExpr {
  grouping = "(" ")",
}
type EOOType {
  grouping = "(" ")",
}
type EOOPat {
  grouping = "(" ")",
}

-- Program
prod Prog: EOOProg =
  (tops:EOOTop)*
  "model"
  (model:EOOExpr)
  "output"
  (output:EOOExpr)

-- Tops
prod LetEOOTop : EOOTop =
  "let" rec:"rec"? bindings:EOOBinding ("and" bindings:EOOBinding)* "end"
prod DynVarEOOTop : EOOTop =
  "dynvar" ns:LName ("," ns:LName)* ":" ty:EOOType "end"

-- Parameters
prod PatEOOParam : EOOParam = "(" pat:EOOPat (":" ty:EOOType)? ")"
prod NameEOOParam : EOOParam = n:LName
prod IgnoreEOOParam : EOOParam = "_"

-- Bindings
prod Simple : EOOBinding =
  n:LName params:EOOParam* (":" ty:EOOType)? "=" body:EOOExpr

-- Exprs
prod Var : EOOExpr = n:LName
prod Num : EOOExpr = f:Float
prod True : EOOExpr = "true"
prod False : EOOExpr = "false"
prod Con : EOOExpr = n:UName
prod Unit : EOOExpr = "()"

infix Add : EOOExpr = "+"
infix Sub : EOOExpr = "-"
infix Mul : EOOExpr = "*"
infix Div : EOOExpr = "/"
infix Pow : EOOExpr = "^"
infix Eq : EOOExpr = "="
infix Lt : EOOExpr = "<"

prod If : EOOExpr = "if" c:EOOExpr "then" t:EOOExpr "else" e:EOOExpr
prod Let : EOOExpr =
  "let" rec:"rec"? bindings:EOOBinding ("and" bindings:EOOBinding)*
  "in" body:EOOExpr
prod Abs : EOOExpr = "\\" params:EOOParam+ "." body:EOOExpr
prod Matching : EOOExpr =
  "begin" "match" scrut:EOOExpr "with"
    "|"? arms:{pat:EOOPat "->" body:EOOExpr}
    arms:{"|" pat:EOOPat "->" body:EOOExpr}*
  "end"
infix left Tup : EOOExpr = ","
infix left App : EOOExpr = empty
infix right Cons : EOOExpr = op:"::"
infix right Seq : EOOExpr = ";"
postfix Access : EOOExpr = "." (field:LIdent | idx:UInt)

-- EOO Specific Exprs
postfix Prim : EOOExpr = "'"
prod DynVar : EOOExpr =
  "dynvar" ns:LName ("," ns:LName)* ":" ty:EOOType "in" body:EOOExpr

precedence {
  Prim;
  Access;
  App;
  Tup Seq;
  Pow;
  Mul Div;
  Add Sub;
  Eq Lt;
  If;
  Let Abs;
}

-- Patterns
prod WildEOOPat : EOOPat = "_"
prod BindEOOPat : EOOPat = n:LName
prod TrueEOOPat : EOOPat = "true"
prod FalseEOOPat : EOOPat = "false"
prod ConEOOPat : EOOPat = parts:UName
prod UnitEOOPat : EOOPat = "()"
infix right AppEOOPat : EOOPat = empty
infix left TupEOOPat : EOOPat = ","
infix left SeqEOOPat : EOOPat = ";"
infix right ConsEOOPat : EOOPat = "::"

precedence {
  AppEOOPat;
  ConsEOOPat;
  TupEOOPat;
}

-- Types
prod VarOType : EOOType = n:LName
prod ConOType : EOOType = n:UName
prod WildOType : EOOType = "_"
postfix AppOType : EOOType = n:UName
infix left TupEOOType : EOOType = "*"
infix left CommaEOOType : EOOType = ","
infix right ArrowOType : EOOType = "->"
precedence {
  AppOType;
  TupOType;
  ArrowOType;
  CommaOType;
}

-------------------------------------------------------------------

include "lib/eoo-lexer.mc"

-- Basic tokens
token String {
  repr = StringRepr {},
  constructor = StringTok,
  fragment = StringTokenParser,
  ty = String,
}
token UInt {
  repr = IntRepr {},
  constructor = IntTok,
  fragment = UIntTokenParser,
  ty = Int,
}
token Char {
  repr = CharRepr {},
  constructor = CharTok,
  fragment = CharOrTickTokenParser,
}
token Float {
  repr = FloatRepr {},
  constructor = FloatTok,
  fragment = UFloatTokenParser,
}
token LIdent {
  repr = LIdentRepr {},
  constructor = LIdentTok,
  fragment = LIdentTokenParser,
  ty = String,
}
token UIdent {
  repr = UIdentRepr {},
  constructor = UIdentTok,
  fragment = UIdentTokenParser,
  ty = String,
}
-- Wrapping tokens that just change the type in the AST
token UName {
  base = UIdent,
  wrap = nameNoSym,
  ty = Name,
}
token LName {
  base = LIdent,
  wrap = nameNoSym,
  ty = Name,
}

-- Token types only used through literals
token {fragment = OperatorTokenParser,}
token {fragment = CommaTokenParser,}
token {fragment = SemiTokenParser,}
token {fragment = SemiSemiTokenParser,}
token {fragment = BracketTokenParser,}
token {fragment = ArrayDelimTokenParser,}
token {fragment = UnitTokenParser,}
